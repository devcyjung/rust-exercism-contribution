{%- macro render_tree(tree) -%}
{%- if tree.children -%}
    Tree::with_children(
        "{{ tree.label }}".to_string(),
        vec![
            {%- for child in tree.children -%}
                {{ self::render_tree(tree=child) }},
            {%- endfor -%}
        ],
    )
{%- else -%}
    Tree::new("{{ tree.label }}".to_string())
{%- endif -%}
{%- endmacro -%}

{%- macro render_vec(values) -%}
vec![
    {%- for value in values -%}
        "{{ value }}".to_string(),
    {%- endfor -%}
]
{%- endmacro -%}

{% for test_group in cases %}
/// {{ test_group.description }}
mod {{ test_group.cases[0].property | make_ident }} {
    use pov::*;
    use pretty_assertions::assert_eq;

{% for test in test_group.cases %}
#[test]
#[ignore]
fn {{ test.description | make_ident }}() {
    let input = {{ self::render_tree(tree=test.input.tree) }};
    let from = "{{ test.input.from }}".to_string();
    {%- if test.property == "fromPov" -%}
        let result = input.pov_from(&from);
        {%- if not test.expected -%}
            let expected: Option<Tree<String>> = None;
        {%- else -%}
            let expected = Some({{ self::render_tree(tree=test.expected) }});
        {%- endif -%}
        assert_eq!(result.map(|t| crate::test_util::tree_to_sorted(&t)), expected.map(|t| crate::test_util::tree_to_sorted(&t)));
    {%- elif test.property == "pathTo" -%}
        let to = "{{ test.input.to }}".to_string();
        let result = input.path_to(&from, &to);
        {%- if not test.expected -%}
            let expected: Option<Vec<String>> = None;
        {%- else -%}
            let expected = Some({{ self::render_vec(values=test.expected) }});
        {%- endif -%}
        assert_eq!(result, expected);
    {%- else -%}
        Invalid property: {{ test.property }}
    {%- endif -%}
}
{% endfor %}
}
{% endfor %}

mod test_util {
    use pov::*;
    pub fn tree_to_sorted<T: Ord + Clone + std::fmt::Debug>(tree: &Tree<T>) -> Tree<T> {
        let mut children = tree.get_children();
        children.sort_unstable_by_key(|child| child.get_label());
        Tree::with_children(tree.get_label(), children.iter().map(|c| tree_to_sorted(c)).collect())
    }
}
